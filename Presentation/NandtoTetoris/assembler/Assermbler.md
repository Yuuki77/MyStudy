---
marp: false
header: "header text"
footer: "footer text"
---

<!-- $theme: gaia -->
<!-- $size: 16:9 -->
<!-- page_number: true -->
<!-- paginate: true -->

# Marp for VS Code スライドサンプル

**_@gonkunkun_**

---

## 目次

- assembler とは
- hack aseembly の復習(長い道のり)
- 一般的なアセンブラーの話と hack ではどうかという話(いらない気もするがあったのでやった)
- hack assembler の話
- 課題の話

---

## アセンブラー

- 機械語のコードを実行できるコンピュータを作りました。
- アセンブリ言語でプログラミングをしてました、
- その隙間にアセンブラを作りましょ。
- 初めてのソフトウェアですよ（ついに）

---

## アセンブラー図

![](Image/2020-06-22-21-30-30.png)

---

## アセンブラーをどこで実行するか

- クロスコンパイルするぜ

* アセンブラをマシンコードで書かなくて良い(多分そういうこと)
* 別のコンピュータですでに実装されている高レベルの言語で書くことができる

---

## 俺たちの Hack assembly どんなんだっけ

- 任意のコードを変換しないといけない（それはそうだがむずそう）
- 両方の文法を知らないといけないよね
- Hack aseembly は A 命令 C 命令 symbol によって構成されているぜ

---

## 3 つ の Register

![](Image/2020-06-26-23-58-16.png)

---

## Hack assembly

![](Image/2020-06-23-22-20-21.png)

---

## A 命令

### Assermbly 文法

- @で始まり、
  - 非負数の 10 進数で表される ex. @20
  - シンボルで表される ex. @tmp

A レジスタに 15 ビットの値を設定するために使える.つまり、特定の値を A レジスタに値を設定することができる

---

## A 命令

### できること

1.  A レジスタを用いて定数を代入する方法(プログラムによって定数を代入する方法は A 命令以外できない)
2.  メモリ操作に使う(A レジスタにメモリアドレスを指定することでその後に続く、C 命令に置いて、A レジスタでしたいしたメモリ位置にあるデータを操作することができる)
3.  その後に移動するための C 命令を用いることで、jump するアドレスを指定するすることが できる

メモリを操作する前には A 命令をする必要がありますよ

---

## A 命令

![](Image/2020-06-27-00-16-18.png)

---

## A 命令

![](Image/2020-06-27-17-44-07.png)

---

## A 命令 シンボルでかくと　 binary 文法

![](Image/2020-06-22-23-26-57.png)

---

## C 命令

![](Image/2020-06-22-23-38-09.png)

---

## C 命令

基本的にやりたいこと

- 計算の結果をどこに保存するか、
- ジャンプするかどうかを決めるかどうか

c 命令と A 命令を一緒に用いることで、コンピュータで行う全ての命令を実行すること ができる

---

## C 命令

- destination、computation、および jump の領域で構成されるよ
  ![](Image/2020-06-27-15-04-46.png)

---

## dest のれい

![](Image/2020-06-27-15-52-19.png)

---

## Comp 領域の仕様

- 7 ビットされるコマンドを実行するができるぜ
- destination、computation、および jump の領域で構成されるよ
- assembly ではこんな感じで表現されるぜ
  ![](Image/2020-06-27-15-04-46.png)

---

## jump

![](Image/2020-06-27-15-54-04.png)

---

## JMP 領域の仕様

- 3 ビットで表現されるぜ
  ![](Image/2020-06-27-15-27-45.png)

---

## c 命令　のれい

![](Image/2020-06-27-15-18-17.png)

---

## c 命令　のれい

![](Image/2020-06-27-15-23-40.png)

---

## c 命令　のれい

![](Image/2020-06-27-15-28-22.png)

---

## C 命令

- ３つの要素で構成されている
- string processing でできるよ
- テーブルから対応している binary を見つけてこよう
- 高級言語で 0 と 1 のテキストファイルを吐き出して、それをパソコンに読んでもらおう

---

## A レジスタの衝突

- A レジスタは c 命令においてデータメモリの位置を指定するのに使う(M と一緒に使う)
- A レジスタは c 命令によって命令メモリの位置を指定するのに使う(jump と一緒に使う)

jmp をする C 命令において M を参照するべきではない

---

## シンボル

![](Image/2020-06-27-16-10-48.png)

---

## handleing symbols

- symbols を使った方が抽象化されたコードをかけるので、
  よりよ安いコードかけるのでいいですよね

  ![](Image/2020-06-23-22-16-11.png)

---

## symbol 使う理由

- プログラマはこれらが実こにあるのかを全く気にしなくて良い

-　シンボル使わないと数字ガチ打ちのけい

- assermber ではこのアドレスの割り当てをやってあげないといけない

![](Image/2020-06-23-22-20-21.png)

---

## symbol2 ラベルシンボル

- もう一つの種類のシンボルは、goto コマンドの目的地を表すラベルシンボル。この例では、LOOP、STOP、END の 3 つのシンボルがある。

![](Image/2020-06-23-22-20-21.png)

---

## symbol3 -定義済みシンボル

復習終わり

仮想レジスタ、スクリーン、キーボードなど、定義済みシンボル。
例では、 R0 と R1 がそうである

![](Image/2020-06-23-22-20-21.png)

---

## 一般的にアセンブリーをどのように読んでいくか

1. ファイルを上から下に読んでいくが、スペースとかコメントは無視するようにする

---

## step 2 要素ごとの分割

- string を要素ごとに分ける
  ![](Image/2020-06-22-22-16-24.png)

---

## step 3 対応するバイナリーを探す

- それぞれの要素を読み込むぜ
- それに対応する binary に書き換える
  ![](Image/2020-06-22-22-18-26.png)

---

## step 4 一つの bainary にまとめて出力する

- これでプログラムは実行することができるようになる
  ![](Image/2020-06-22-22-20-29.png)

---

## シンボル　どうする問題

- ラベルシンボル
  - ユーザが定義するシンボルであり、プログラムの特定のアドレスにジャンプするための変数(goto に使われる)
- 変数シンボル
  - ユーザ定義したシンボルの中で、事前に言語に定義されておらず、かつ ラベルシンボルで定義されてない奴、それは変数として扱われ、このシンボルはアセンブラによって一位のメモリアドレスが与えられる。

---

## シンボルどうする問題

![](Image/2020-06-27-13-30-40.png)

---

## シンボル　テーブルや

![](Image/2020-06-27-13-33-15.png)

---

## 変数シンボルのアロケーション

- 使えるメモリを探す
- その値を symboltable に保存していく
  ![](Image/2020-06-27-13-36-15.png)

---

## ラベルシンボルどうする問題

- ラベルは実行するコマンドではない。
- ループとかで呼ばれるので、アドレスを覚えている必要がある
  ![](Image/2020-06-22-22-46-30.png)

---

## ジャンプが先呼ばれるとどうする問題

![](Image/2020-06-22-22-52-25.png)

---

## 俺たちの Hack ではどうするの

- 全ての assembly で動かないといけない
- なんか難しそう
  ![](Image/2020-06-27-13-45-52.png)

---

## A 命令

![](Image/2020-06-27-18-00-00.png)

---

## C 命令

![](Image/2020-06-22-23-38-09.png)

---

## シンボル

![](Image/2020-06-27-18-08-18.png)

---

## アセンブラーで対処しないといけないこと

- インデントとかコメントとか無視しないといけなさそう
- 命令を対処する
  - A, C 命令
- シンボル
  - 変数、ラベル

シンブルの実装が難しそうなので、とりあえずシンボルなしのケースを考えます

---

## シンボルないとこんな感じですな

1. whitespace
2. 命令
   ![](Image/2020-06-27-18-16-12.png)

---

# whitespace

- ただただ、コメントの empty line はアセンブラーで無視するようにしましょう
  ![](Image/2020-06-27-18-18-52.png)

---

# 命令

![](Image/2020-06-27-18-20-16.png)

---

## A 命令の翻訳

- ＠十進数のプラスの値だったら、二進数に変換する。
- 15 ビッドで表現されるので、足りないところは 0 でうめる

- symbol の場合もありますが、それはまた後で考えましょう
  ![](Image/2020-06-27-18-23-07.png)

---

## C 命令の翻訳

- C 命令は 3 つの coponent で構成されるので、それぞれの対応を考えていきましょう
- dest が empty であれば =は省略
- jump が empty であれば ;は省略

![](Image/2020-06-27-18-29-31.png)

string processing でできるということ

---

## aseembly 基本戦略

symbol ない奴はこれで動く

![](Image/2020-06-23-22-10-17.png)

---

## symbol 三種類

![](Image/2020-06-27-18-37-05.png)

---

## Handlling pre defined symbol

- 定義された記号を、対応する値（10 進数）に置き換える
- 10 進数を 2 進数に置き換える（それはさっき話した）
  ![](Image/2020-06-23-22-50-25.png)

---

## Go to の symbol どうするねん

- プログラムの中で goto コマンドを使ってジャンプしたい場所を表すために使う
- (ラベル名)　()で囲まれてたら symbol ですね
- プログラムの中で XXX が出てきたときには、メモリのアドレスに置き換える
- 命令番号を記録
  アドレスに置き換えていきましょう
- @LOOP -> @4 になる

ex.
![](Image/2020-06-23-23-03-18.png)

---

## Symbol table predefined symbol

- これは A 命令にしか存在しません
- 23 この predefined symbol がありますが、
  これに対応する数字を二進数に変換しましょう
  ![](Image/2020-06-27-18-38-32.png)

---

## ラベルシンボル

- go to の　行先のアドレスを表すラベルとして使われる
- これはコードを生み出さない（アドレスを保持する必要があるだけなので）
- ()で始まるで（）で始まるのには理由があるらしい
- @Loop とかを　＠４と変換しなくてはいけない
  ![](Image/2020-06-27-18-43-11.png)

---

## 変数シンボル

- predefined にもなく()のなかにない@は変数シンボルである
- それぞれの変数 16 ビットのユニークなアドレスが振られる
- 値は 16 から始まります。

![](Image/2020-06-27-18-47-49.png)

---

## symbol table で管理しよう

- シンボル（ラベル名）とアドレスのペアを管理しましょう

first loop

0. predefined のやつを追加しましょう
1. ラベル変数を追加しましょう
   （ライン番号を数えながら、）

   ![](Image/2020-06-27-18-53-37.png)

---

# Symbol table3

second loop

- この時点で symbol-table にない奴は symbol だ
  ![](Image/2020-06-24-20-46-48.png)

---

# アセンブラのアルゴリズムの解法

![](Image/2020-06-24-20-53-49.png)

---

# アセンブラのアルゴリズムの解法

1. 最初に入力ファイル全体を調べて、左の括弧で始まる命令を検索します。そして、そのペア、xxx、アドレスをシンボルテーブルに追加していきます。
2.

![](Image/2020-06-24-20-53-49.png)

---

<!-- # omake

- 入力を読み込んで、分割していこう
- 指定されたファイルを読み込んでいこう
- 読み込んだファイルの次のコマンドを毎回取得できるよう
- 読み込んだコマンドをコンポーネントに分割していこう
  ![](Image/2020-06-24-21-26-18.png)

--- -->

<!-- # 実装方法

頑張ろう
![](Image/2020-06-24-21-27-12.png)

--- -->

<!-- # 実装方法

どんなコマンドなんだろう
![](Image/2020-06-24-21-32-19.png)

--- -->

<!-- # C 命令のやり方

![](Image/2020-06-24-21-49-39.png)

--- -->
<!--
# symbol table

![](Image/2020-06-24-22-03-30.png)

--- -->

<!-- # symbol table

![](Image/2020-06-24-22-04-14.png)

--- -->

# 実装の提案

![](Image/2020-06-24-22-14-17.png)

---

# project の概要

![](Image/2020-06-24-22-18-14.png)

---

## project の概要

![](Image/2020-06-27-19-09-58.png)

---

## project の概要

![](Image/2020-06-24-22-48-00.png)

---

project の概要
![](Image/2020-06-27-19-08-01.png)

---

# まとめ

- hack.aasm ファイルが与えられる
- 上からそれぞれのラインを読んでいき
- それが A 命令 ならば - 十進数の値を二進数に変換する
- C 命令 ならば、それぞれの値を 3 つの component にわけて処理をしていこう

最後にこれら全てをまとめる - 各行は 16 個の 0 と 1 の文字列で構成される - 記号のない A 命令と C 命令だけで構成されたプログラムが完成

- 最後にそれをファイルとして書き出しましょう

---

Add

![](Image/2020-06-24-22-57-49.png)

---

Add

![](Image/2020-06-24-22-58-40.png)

---

# pong

https://youtu.be/0y8JPx0ZakY?list=PLrDd_kMiAuNmSb-CKWQqq9oBFN_KNMTaI&t=1170
![](Image/2020-06-24-23-00-45.png)

---

おしまい

![](Image/2020-06-24-23-29-06.png)

---
